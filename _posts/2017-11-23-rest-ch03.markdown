---
layout: post
title:  "REST - Chapter 3. Network-based Architectural Styles"
date:   2017-11-23 21:13:00 +0500
categories: papers
---

By Roy Thomas Fielding. 2000

## Chapter 3. Network-based Architectural Styles

### Blackboard
Blackboard architectural style consists of a central repository and a set of components (knowledge sources) that operate opportunistically upon the repository.

### Properties
Net Performance, UP Performance, Efficiency, Scalability, Simplicity, Evolvability, Extensibility, Customizability, Configurability, Reusability, Visibility, Portability, Reliability.

### 3.2 Data-flow Styles

### 3.2.1 Pipe and Filter (PF)
In a pipe and filter style, each component (filter) reads streams of data on its inputs and produces streams of data on its outputs, usually while applying a transformation to the input streams and processing them incrementally so that output begins before the input is completely consumed. This style is also referred to as a one-way data flow network

The constraint is that a filter must be completely independent of other filters (zero coupling): it must not share state, control thread, or identity with the other filters on its upstream and downstream interfaces

### 3.2.2 Uniform Pipe and Filter (UPF)
The uniform pipe and filter style adds the constraint that all filters must have the same interface.  Restricting the interface allows independently developed filters to be arranged at will to form new applications. I

### 3.3 Replication Styles

### 3.3.1 Replicated Repository (RR)
Systems based on the replicated repository style improve the accessibility of data and scalability of services by having more than one process provide the same service.

### 3.3.2 Cache ($)
A variant of replicated repository is found in the cache style: replication of the result of an individual request such that it may be reused by later requests.

### Lazy Replication
Lazy replication occurs when data is replicated upon a not-yet-cached response for a request, relying on locality of reference and commonality of interest to propagate useful items into the cache for later reuse.

### Active Replication
Active replication can be performed by pre-fetching cacheable entries based on anticipated requests.

### 3.4 Hierarchical Styles

### 3.4.1 Client-Server (CS)
A server component, offering a set of services, listens for requests upon those services. A client component, desiring that a service be performed, sends a request to the server via a connector. The server either rejects or performs the request and sends a response back to the client

### 3.4.2 Layered System (LS) and Layered-Client-Server (LCS)
A layered system is organized hierarchically, each layer providing services to the layer above it and using services of the layer below it.  Layered systems hide the inner layers from all except the adjacent outer layer, thus improving evolvability and reusability.

Architectures based on layered-client-server are referred to as two-tiered, three-tiered, or multi-tiered architectures in the information systems literature

### 3.4.3 Client-Stateless-Server (CSS)
The client-stateless-server style derives from client-server with the additional constraint that no session state is allowed on the server component. Each request from client to server must contain all of the information necessary to understand the request, and cannot take advantage of any stored context on the server. Session state is kept entirely on the
client.

### 3.4.4 Client-Cache-Stateless-Server (C$SS)
A cache acts as a mediator between client and server in which the responses to prior requests can, if they are considered cacheable, be reused in response to later requests that are equivalent and likely to result in a response identical to that in the cache if the request were to be forwarded to the server.

### 3.4.5 Layered-Client-Cache-Stateless-Server (LC$SS)
The layered-client-cache-stateless-server style derives from both layered-client-server and client-cache-stateless-server through the addition of proxy and/or gateway components. An example system that uses an LC$SS style is the Internet domain name system (DNS).

### 3.4.6 Remote Session (RS)
Each client initiates a session on the server and then invokes a series of services on the server, finally exiting the session. Application state is kept entirely on the server. This style is typically used when it is desired to access a remote service using a generic client (e.g., TELNET) or via an interface that mimics a generic client (e.g. FTP)

### 3.4.7 Remote Data Access (RDA)
A variant of client-server that spreads the application state across both client and server. A client sends a database query in a standard format, such as SQL, to a remote server. The server allocates a workspace and performs the query, which may result in a very large data set. The client can then make further operations upon the result set (such as table joins) or retrieve the result one piece at a time

Transaction mechanisms (e.g., two-phase commit) can be used to fix the reliability problem, though at a cost of added complexity and interaction overhead

### 3.5 Mobile Code Styles
Mobile code styles use mobility in order to dynamically change the distance between the processing and source of data or destination of results.

Introducing the concept of location makes it possible to model the cost of an interaction between components at the design level. In particular, an interaction between components that share the same location is considered to have negligible cost when compared to an interaction involving communication through the network.

### 3.5.1 Virtual Machine (VM)
The code must be executed in some fashion, preferably within a controlled environment to satisfy security and reliability concerns

### 3.5.2 Remote Evaluation (REV)
A client component has the know-how necessary to perform a service, but lacks the resources (CPU cycles, data source, etc.) required, which happen to be located at a remote site.

The client sends the know-how to a server component at the remote site, which in turn executes the code using the resources available there. The results of that execution are then sent back to the client. 

The remote evaluation style assumes that the provided code will be executed in a sheltered environment, such that it won’t impact other clients of the same server aside from the resources being used.

### 3.5.3 Code on Demand (COD)
A client component has access to a set of resources, but not the know-how on how to process them. It sends a request to a remote server for the code representing that know-how, receives that code, and executes it locally

### 3.5.4 Layered-Code-on-Demand-Client-Cache-Stateless-Server (LCODC$SS)
Since the code can be treated as just another data element, this does not interfere with the 53advantages of the LC$SS style.

### 3.5.5 Mobile Agent (MA)
An entire computational component is moved to a remote site, along with its state, the code it needs, and possibly some data required to perform the task.

An application can be in the midst of processing information at one location when it decides to move to another location, presumably in order to reduce the distance between it and the next set of data it wishes to process.

### 3.6 Peer-to-Peer Styles

### 3.6.1 Event-based Integration (EBI)
The event-based integration style, also known as the implicit invocation or event system style, reduces coupling between components by removing the need for identity on the connector interface. Instead of invoking another component directly, a component can announce (or broadcast) one or more events. Other components in a system can register interest in that type of event and, when the event is announced, the system itself invokes all of the registered components

### The Invisible Hand
Like pipe-and-filter systems, a higher-level configuring architecture is needed for the “invisible hand” that places components on the event interface

### 3.6.2 C2
It combines event-based integration with layered-client-server. Asynchronous notification messages going down, and asynchronous request messages going up, are the sole means of intercomponent communication.

C2 does not constrain what should be included with a notification: a flag, a delta of state change

### 3.6.3 Distributed Objects
The distributed objects style organizes a system as a set of components interacting as peers. A chain of related invocations is referred to as an action. State is distributed among the objects.  In order for one object to interact with another, it must know the identity of that other object

### 3.6.4 Brokered Distributed Objects
The brokered distributed object style introduces name resolver components whose purpose is to answer client object requests for general service names with the specific name of an object that will satisfy the request.

### 3.8 Related Work
### 3.8.1 Classification of Architectural Styles and Patterns
A two-dimensional, tabular classification strategy is used with control and data issues as the primary axes, organized by the following categories of features: 

|1.|Which kinds of components and connectors are used in the style;
|2.|How control is shared, allocated, and transferred among the components
|3.|How data is communicated through the system
|4.|How data and control interact
|5.|What type of reasoning is compatible with the style. 

The primary purpose of the taxonomy is to identify style characteristics, rather than to assist in their comparison. 

Buschmann and Meunier describe a classification scheme that organizes patterns according to granularity of abstraction, functionality, and structural principles. The granularity of abstraction separates patterns into three categories

|1.|Architectural frameworks (templates for architectures)
|2.|Design patterns
|3.|Idioms

### 3.8.2 Distributed Systems and Programming Paradigms
Interaction paradigms represent the communication aspects of software architectural styles. He describes paradigms for one-way data flow through networks of

|1.|filters (pipe-and-filter)
|2.|client-server
|3.|heartbeat
|4.|probe/echo
|5.|broadcast
|6.|token passing
|7.|replicated servers
|8.|replicated workers with bag of tasks

### 3.8.3 Middleware
Bernstein defines middleware as a distributed system service that includes standard programming interfaces and protocols. These services are called middleware because they act as a layer above the OS and networking software and below industry-specific applications

#### Source
[Architectural Styles and the Design of Network-based Software Architectures][rest]

[rest]: http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm