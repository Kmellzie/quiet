---
layout: post
title:  "REST - Chapter 5. Representational State Transfer (REST)"
date:   2017-11-25 21:13:00 +0500
categories: papers
---

By Roy Thomas Fielding. 2000

## Chapter 5. Representational State Transfer

### 5.1.1 Starting with the Null Style

|1|A designer starts with nothing—a blank slate, whiteboard, or drawing board—and builds-up an architecture from familiar components
until it satisfies the needs of the intended system
|2|A designer starts with the system needs as a whole, without constraints, and then incrementally identifies and applies constraints to elements of the system in order to differentiate the design space and allow the forces that influence system behavior to flow naturally, in harmony with the
system

Where the first emphasizes creativity and unbounded vision, the second emphasizes restraint and understanding of the system context

### 5.1.2 Client-Server
Separation of concerns is the principle behind the client-server constraints

### 5.1.3 Stateless
Each request from client to server must contain all of the information necessary to understand the request, and cannot take advantage of any stored context on the server

Trade-off

|It may decrease network performance by increasing the repetitive data (per-interaction overhead) sent in a series of requests
|Placing the application state on the client-side reduces the server’s control over consistent application behavior
|The application becomes dependent on the correct implementation of semantics across multiple client versions

### 5.1.4 Cache
Cache constraints require that the data within a response to a request be implicitly or explicitly labeled as cacheable or non-cacheable. If a response is cacheable, then a client cache is given the right to reuse that response data for later, equivalent requests.

Trade-off

|A cache can decrease reliability if stale data within the cache differs significantly from the data that would have been obtained had the request been sent directly to the server.

### 5.1.5 Uniform Interface
By applying the software engineering principle of generality to the component interface, the overall system architecture is simplified and the visibility of interactions is improved.

Trade-off

|A uniform interface degrades efficiency, since information is transferred in a standardized form rather than one which is specific to an application’s needs

REST is defined by four interface constraints

|1|Identification of resources
|2|Manipulation of resources through representations
|3|Self-descriptive messages
|4|Hypermedia as the engine of application state

### 5.1.6 Layered System
Layers can be used to encapsulate legacy services and to protect new services from legacy clients.  Intermediaries can also be used to improve system scalability by enabling load balancing of services

Trade-off
|Layered systems add overhead and latency to the processing of data, reducing user-perceived performance

Placing shared caches at the boundaries of an organizational domain can result in significant performance benefits

### Intermediary Components
Within REST, intermediary components can actively transform the content of messages because the messages are self-descriptive and their semantics are visible to intermediaries

### 5.1.7 Code-On-Demand
REST allows client functionality to be extended by downloading and executing code in the form of applets or scripts.

### Oxímoron
Oxímoron es una figura literaria que consiste en combinar dos expresiones de significado opuesto en una misma estructura, con el objetivo de generar un tercer concepto con un nuevo sentido. 

El oxímoron funciona en un sentido metafórico ya que su significado literal resulta absurdo o incoherente. Por ejemplo: “Su obra está cubierta de una luminosa oscuridad” o “La droga ofrece un placer doloroso”

Esta figura retórica permite ocultar una intención sarcástica bajo una expresión que, en apariencia, es absurda: “Un silencio atronador descendió desde las galerías hasta el escenario y desconcertó a los actores”.

### Optional Constraint
The notion of an optional constraint may seem like an oxymoron. It means that the architecture only gains the benefit (and suffers the disadvantages) of the optional constraints when they are known to be in effect for some realm of the overall system

### 5.2 REST Architectural Elements
The Representational State Transfer (REST) style focuses on the roles of components, the constraints upon their interaction with other components, and their interpretation of significant data elements

### 5.2.1 Data Elements
When information needs to be moved from the location where it is stored to the location where it will be used there are only three fundamental options:

|Option 1|Render the data where it is located and send a fixed-format image to the recipient

Allows all information about the true nature of the data to remain hidden within the sender, preventing assumptions from being made about the data structure and making client implementation easier.  However, it also severely restricts the functionality of the recipient and places most of the processing load on the sender, leading to scalability problems

|Option 2|Encapsulate the data with a rendering engine and send both to the recipient

It provides information hiding while enabling specialized processing of the data via its unique rendering engine but limits the functionality of the recipient to what is anticipated within that engine and may vastly increase the amount of data transferred

|Option 3|Send the raw data to the recipient along with metadata that describes the data type, so that the recipient can choose their own rendering engine

It allows the sender to remain simple and scalable while minimizing the bytes transferred, but loses the advantages of information hiding and requires that both sender and recipient understand the same data types.

### Representation of Resources
REST components communicate by transferring a representation of a resource in a format matching one of an evolving set of standard data types, selected dynamically based on the capabilities or desires of the recipient and the nature of the resource.

### Data Elements

|DE|Example
|resource|The intended conceptual target of a hypertext reference
|resource identifier|URL, URN
|resource metadata|source link, alternates, vary
|representation|HTML document, JPEG image
|representation metadata|media type, last-modified time
|control data|if-modified-since, cache-control

### 5.2.1.1 Resources and Resource Identifiers

### Resource
Any information that can be named can be a resource.  A resource is a conceptual mapping to a set of entities, not the entity that corresponds to the mapping at any particular point in time

Some resources are static in the sense that, when examined at any time after their creation, they always correspond to the same value set. Others have a high degree of variance in their value over time

|For example, the “authors’ preferred version” of an academic paper is a mapping whose value changes over time, whereas a mapping to “the paper published in the proceedings of conference X” is static. These are two distinct resources, even if they both map to the same value at some point in time.

### Identifiers
The naming authority that assigned the resource identifier, making it possible to reference the resource, is responsible for maintaining the semantic validity of the mapping

### 5.2.1.2 Representations
A representation is a sequence of bytes, plus representation metadata to describe those bytes. Other commonly used but less precise names for a representation include: document, file, and HTTP message entity, instance, or variant.

### Metadata
Metadata is in the form of name-value pairs, where the name corresponds to a standard that defines the value’s structure and semantics.  

Response messages may include both representation metadata and resource metadata: information about the resource that is not specific to the supplied representation.

### Control Data
Control data defines the purpose of a message between components, such as the action being requested or the meaning of a response.  It is also used to parameterize requests and override the default behavior of some connecting elements

|For example: Cache behavior can be modified by control data included in the request or response message.

Depending on the message control data, a given representation may indicate the current state of the requested resource, the desired state for the requested resource, or the value of some other resource

### Media Type
The data format of a representation is known as a media type.  A representation can be included in a message and processed by the recipient according to the control data of the message and the nature of the media type

The design of a media type can directly impact the user-perceived performance.  Any data that must be received before the recipient can begin rendering the representation adds to the latency of an interaction

### Data Format
A data format that places the most important rendering information up front, such that the initial information can be incrementally rendered while the rest of the information is being received, results in much better user-perceived performance than a data format that must be entirely received before rendering can begin

### 5.2.2 Connectors
Since a connector manages network communication for a component, information can be shared across multiple interactions in order to improve efficiency and responsiveness.

All REST interactions are stateless. This restriction accomplishes four functions:

|1.|It removes any need for the connectors to retain application state between requests
|2.|It allows interactions to be processed in parallel without requiring that the processing mechanism understand the interaction semantics
|3.|It allows an intermediary to view and understand a request in isolation, which may be necessary when services are dynamically rearranged
|4.|It forces all of the information that might factor into the reusability of a cached response to be present in each request.

### In-Parameters

|Request control data
|A resource identifier indicating the target of the request
|An optional representation

### Out-Parameters

|Response control data
|Optional resource metadata
|Optional representation

### Client and Server
The primary connector types are client and server. The essential difference between the two is that a client initiates communication by making a request, whereas a server listens for connections and responds to requests in order to supply access to its services. 

A component may include both client and server connectors

### Cache
It can be located on the interface to a client or server connector.  A cache may be used by a client to avoid repetition of network communication, or by a server to avoid repeating the process of generating a response, with both cases serving to reduce interaction latency.

### Shared Cache
Some cache connectors are shared, meaning that its cached responses may be used in answer to a client other than the one for which the response was originally obtained.  Shared caching can be effective at reducing the impact of “flash crowds”

Shared caching can also lead to errors if the cached response does not match what would have been obtained by a new request
 
A component can override cache defaults by including control data that marks the interaction as cacheable, non-cacheable or cacheable for only a limited time.

### Resolver
A resolver translates partial or complete resource identifiers into the network address information needed to establish an inter-component connection

For Example, most URI include a DNS hostname as the mechanism for identifying the naming authority for the resource. In order to initiate a request, a Web browser will extract the hostname from the URI and make use of a DNS resolver to obtain the Internet Protocol address for that authority.

### Tunnel
It simply relays communication across a connection boundary, such as a firewall or lower-level network gateway.  REST components may dynamically switch from active component behavior to that of a tunnel.  

The primary example is an HTTP proxy that switches to a tunnel in response to a CONNECT method request

### Components

|origin server|Apache httpd, Microsoft IIS
|gateway|Squid, CGI, Reverse Proxy
|proxy|CERN Proxy, Netscape Proxy, Gauntlet
|user agent|Netscape Navigator, Lynx, MOMspider

### User Agent
A user agent uses a client connector to initiate a request and becomes the ultimate recipient of the response. The most common example is a Web browser

### Origin Server
An origin server uses a server connector to govern the namespace for a requested resource. It is the definitive source for representations of its resources and must be the ultimate recipient of any request that intends to modify the value of its resources.

### Proxy
A proxy component is an intermediary selected by a client to provide interface encapsulation of other services, data translation, performance enhancement, or security protection.

### Gateway
A gateway (a.k.a., reverse proxy) component is an intermediary imposed by the network or origin server to provide an interface encapsulation of other services, for data translation, performance enhancement, or security enforcement

The difference between a proxy and a gateway is that a client determines when it will use a proxy.

### 5.3 REST Architectural Views

### 5.3.1 Process View
It reveals the path of data as it flows through the system.  Although REST components communicate via bidirectional streams, the processing of each direction is independent and therefore susceptible to stream transducers (filters)

### 5.3.2 Connector View
It concentrates on the mechanics of the communication between components.  REST does not restrict communication to a particular protocol, but it does constrain the interface between components, and hence the scope of interaction and implementation assumptions that might otherwise be made between components.

### 5.3.3 Data View
It reveals the application state as information flows through the components.

Since REST is specifically targeted at distributed information systems, it views an application as a cohesive structure of information and control alternatives through which a user can perform a desired task.

### Dynamically Sized Messages
Component interactions occur in the form of dynamically sized messages. Small or medium-grain messages are used for control semantics, but the bulk of application work is accomplished via large-grain messages containing a complete resource representation.

### User-perceived Performance
The user-perceived performance of a browser application is determined by the latency between steady-states: the period of time between the selection of a hypermedia link on one web page and the point when usable information has been rendered for the next web page

### Application Performance
An interesting observation is that the most efficient network request is one that doesn’t use the network. In other words, the ability to reuse a cached response results in a considerable improvement in application performance.

#### Source
[Architectural Styles and the Design of Network-based Software Architectures][rest]

[rest]: http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm